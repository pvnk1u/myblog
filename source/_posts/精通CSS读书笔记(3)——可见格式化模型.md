---
title: "精通CSS读书笔记(3)——可见格式化模型" 
date: 2023-05-30T22:34:39+08:00
draft: false
tags: ["web","css"]
categories:
  - "web"
  - "css"
toc: true
---





浮动、定位和盒模型是学习CSS需要掌握的几个最重要的概念。这几个概念决定了元素在页面上排布和显示的方式，是很多布局技术的基础。搞清楚盒模型的各方面细节，绝对和相对定位的区别，以及浮动及清除的原理之后，使用CSS设计网站会变得更简单、更轻松。



# 盒模型

盒模型是CSS的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。



内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不致于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。



有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不会影响盒子的宽度和高度。因此，outline常用于调试复杂布局，或者演示布局效果。



盒模型如下图所示：

![BoxModel](https://pvnk1u.github.io/images/BoxModel.PNG)



对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。当然，可以覆盖这些样式，要么在自己的样式表里覆盖，要么直接引用重置样式表。



## 盒子大小

默认情况下，元素盒子的width和height属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加5像素的边框和5像素的内边距，同时又想让元素盒子的宽度为100像素，则应该像下面这样把内容区宽度设置为80像素。如果这个元素盒子周围还有10像素的外边距，那么整个盒子占据空间的宽度就是120像素（如下图所示）。

```css
.mybox{
	width: 80px;
	padding: 5px;
	border: 5px solid;
	margin: 10px;
}
```

![WidthBoxModelDemo](https://pvnk1u.github.io/images/WidthBoxModelDemo.PNG)



通过修改box-sizing属性可以改变计算盒子大小的方式。box-sizing的默认值为content-box，即前面例子中看到的那样，把宽度值应用给内容区。通过修改box-sizing的值，设置元素的width和height属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。



如果把box-sizing的值修改为border-box，那么width和height属性的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到width中。这样，如下代码可以实现与上面的图一样的布局。

```css
.mybox{
	box-sizing: border-box;
	width: 100px;
	padding: 5px;
	border: 5px;
	margin: 10px;
}
```

![WidthBoxModelDemo](https://pvnk1u.github.io/images/BoxSizingDemo.PNG)

在很多情况下这都很有用，因为很多情况下，这种计算盒子大小的方式更加直观。之所以说这种计算方式“直观“，是因为现实中的盒子就是这样测量的。



如果把CSS中的盒子想象成一个包装箱，那么箱子的四壁就是边框，从视觉上规定了箱子的大小；内边距就是箱子内部的填充层，用于保护箱子里的物品。在箱子宽度既定的情况下，无论是加厚箱壁还是增加填充层厚度，都会挤压最终可用于盛放物品的空间。这样在码放箱子时，不管它们之间空出多大距离（对应CSS中的外边距），都不会影响箱子本身的宽度，以及箱子内部可用的空间。总之，这是一个有实物可以参照的方案。但是浏览器开发人员决定默认采用另一种方式来计算CSS盒模型的宽度，这实际上并不明智。



好在可以通过设置box-sizing属性来覆盖默认行为，简化CSS布局中的一些常用模式。举个例子：

```css
<div class="group">
	<article class="block">
	</article>
</div>
```

默认情况下，如果想让.group中的.block宽度在任何情况下都占其父元素的1/3，可以使用以下规则：

```css
.group .block{
	width: 33.3333%;
}
```

只要不给.block应用内边距，这样写就没问题。但如果给.block添加了内边距，它的宽度就会变成.group元素的1/3外加应用给它的内边距。如果这是一个三栏布局，那么此时添加内边距很可能会破坏原有布局。下图展示了添加内边距前后的不同之处：

![PaddingDiff](https://pvnk1u.github.io/images/PaddingDiff.PNG)



要解决这个问题，可以再增加一个内部元素，然后改为给这个元素添加内边距。或者，可以设置一个不同的box-sizing值，从而修改盒子宽度的计算方式(如下图所示)：

```css
.group .block{
	width: 33.3333%;
	box-sizing: border-box;
    padding: 20px;
}
```

![BorderBoxBlock](https://pvnk1u.github.io/images/BorderBoxBlock.PNG)



此时，无论添加多少内边距和边框，.block的宽度始终保持为其父元素的1/3。



内边距、边框和外边距可以应用于元素的四边，也可以应用于具体某一边。外边距甚至还可以使用负值，使得元素可以在页面中移动。



内边距和外边距的值可以是CSS规范中规定的任意长度单位（px、em或百分比）。其中，使用百分比长度时，有几个问题需要注意。假设还是前面的那个例子，下面代码中的5%到底是什么意思？

```css
.block{
	margin-left: 5%;
}
```

**这里5%指的是父元素.group宽度的5%。如果.group宽度是100像素，那么这里左外边距的宽度就是5像素。**



如果给一个元素的顶部和底部应用内、外边距，那么使用百分比值应该基于元素的高度来计算，对吧？错，因为元素的高度常常不会被声明，而且会因内容多少而差异很大，所以CSS规定，上、下方位的内、外边距，仍然基于包含块的宽度来计算。这里，包含块就是其父元素，但有时候不一定。具体会在后面详细说明。



## 最大值和最小值

有时候，特别是响应式布局中，给一个元素应用min-width和max-width值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比min-width指定的值更窄，或者扩展到比max-width指定的值更宽。



与此类似的是min-height和max-height属性。不过在CSS中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即便出于种种原因，需要明确设定默认高度，也最好使用min-height，因为这个属性允许盒子随内容扩展。



# 可见格式化模型

有了对盒模型的理解，下一步就可以探讨可见格式化及定位模型了。



大家常说p、h1盒article这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子的形式。相对而言，strong、span和time被称为行内元素，因为它们的内容会以行内盒子的形式显示在行内。



可以使用display属性改变生成的盒子类型。换句话说，可以通过把display属性设置为block，让span变得跟块级元素一样。如果把display属性设置为none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。



CSS中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有元素盒子都会在常规文档流中生成，即position属性的默认值为static。顾名思义，常规文档流中元素盒子的位置，由元素在HTML中的位置决定。



块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。



行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但**行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。**



**由一行文本形成的水平盒子叫行盒子（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。**下图展示了一个段落的块级盒子及其包含的两行文本，其中有一个单词位于显示为行内盒子的strong元素中。

![LineBoxInBlockBox](https://pvnk1u.github.io/images/LineBoxInBlockBox.PNG)



当然，也可以把元素的display属性设置为inline-block。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。



使用表格相关的标记（table、tr、th等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置display属性让非表格元素采用表格的布局方式。只要正确地应用table、table-row和table-cell等值，就可以实现表格布局，无须在HTML标记中使用表格标签。



Flexible Box Layout（也称为Flexbox）和Grid Layout等CSS模块，又进一步扩展了display属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。



在Display Level3模块中，上述外部和内部显示模式的差异正在标准化。在这个模块中，既有显示模式的相关属性和关键字都是可扩展的，从而支持更细粒度的控制。但无论如何，行内盒子和块级盒子仍然是HTML元素默认行为的基础，只是显示当中有了更多选项。





## 匿名盒子

HTML元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在section这个块级元素的开头加入”some text“。此时，”some text“就算没有定义为块级元素，也会被当成块级元素。



```html
<section>
	some text
	<p> some more text</p>
</section>
```

这种情况下，这个盒子被称为匿名块盒子，因为这个盒子并不与任何特定的元素相关。



类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子。除了使用.first-line伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。关键要知道，在屏幕上看到的一切都会从属于某个盒子。



## 外边距折叠

常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，但实践中常常给布局网页带来困惑。**简而言之，垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度。**



如下图所示，当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。

![FoldableMargin](https://pvnk1u.github.io/images/FoldableMargin.PNG)



在一个元素嵌套着另一个元素的情况下，假设没有内边距或边框来分隔外边框，它们的上、下外边距也会折叠。



![FoldableMarginInBox](https://pvnk1u.github.io/images/FoldableMarginInBox.PNG)



乍一看，这种情况不太正常，但事实还不止如此：甚至同一个元素的外边距都能折叠。假设有一个空元素，只有外边距而没有边框或内边距。此时，上外边距与下外边距接触，结果也会折叠：

![FoldableMarginInEmpty](https://pvnk1u.github.io/images/FoldableMarginInEmpty.PNG)



更进一步，如果折叠后的外边距又碰到了其他元素的外边距，还会继续折叠。

![ContinueFoldMargin](https://pvnk1u.github.io/images/ContinueFoldMargin.PNG)



这就是再多的空段落也只会占用一小块空间的原因：它们的外边距都折叠成一个小外边距了。



外边距折叠好像很奇怪，实际上却很有用。以一个包含几段文本的页面为例：

![ReasonOfMargenFold](https://pvnk1u.github.io/images/ReasonOfMargenFold.PNG)

这一段上方的间距等于这一段的上外边距。如果没有外边距折叠，则后续所有段落的间距，都是相邻的上、下外边距之和。结果就是段间距是上页边距的两倍。有了外边距折叠，段间距才会与页边距相等。



外边距折叠只会发生在文档常规文本流中块级盒子的垂直方向上。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。



## 包含块

知道什么决定一个元素的包含块非常重要，前面的例子中，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。



确定元素的包含块，要看元素是如何定位的。**如果元素的定位方式为静态定位（即不指定position属性的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的display属性值必须能够提供类似块级的上下文，如block、inline-block、table-cell、list-item等。**



**默认情况下，width、height、margin和padding的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了absolute或fixed，那么计算依据就会发生变化。**接下来逐个讨论不同的定位模型，以及如何确定与之对应的包含块。



## 相对定位

把一个元素的display属性设置为relative，该元素仍然会呆在原来的地方。但此后，可以通过设置top、right、bottom和left属性，使该元素相对于初始位置平移一段距离。比如设置top属性为20像素，该元素就会相对于其初始位置垂直向下平移20像素。而设置left属性为20像素，则会将该元素向右移动20像素，其左侧会出现空白。

```css
.mybox{
	position: relative;
	left: 20px;
	top: 20px;
}
```

![relative](https://pvnk1u.github.io/images/relative.PNG)



无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致遮挡其他元素。



## 绝对定位

相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，彷佛绝对定位的那个元素没有存在过一样。

