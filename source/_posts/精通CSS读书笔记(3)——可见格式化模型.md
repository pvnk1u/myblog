---
title: "精通CSS读书笔记(3)——可见格式化模型" 
date: 2023-05-30T22:34:39+08:00
draft: false
tags: ["web","css"]
categories:
  - "web"
  - "css"
toc: true
---





浮动、定位和盒模型是学习CSS需要掌握的几个最重要的概念。这几个概念决定了元素在页面上排布和显示的方式，是很多布局技术的基础。搞清楚盒模型的各方面细节，绝对和相对定位的区别，以及浮动及清除的原理之后，使用CSS设计网站会变得更简单、更轻松。



# 盒模型

盒模型是CSS的核心概念，描述了元素如何显示，以及（在一定程度上）如何相互作用、相互影响。页面中的所有元素都被看作一个矩形盒子，这个盒子包含元素的内容、内边距、边框和外边距。



内边距（padding）是内容区周围的空间。给元素应用的背景会作用于元素内容和内边距。因此，内边距通常用于分隔内容，使其不致于散布到背景的边界。边框（border）会在内边距外侧增加一条框线，这条框线可以是实线、虚线或点划线。边框的外侧是外边距（margin），外边距是围绕在盒子可见部分之外的透明区域，用于在页面中控制元素之间的距离。



有一个与边框类似的属性，即轮廓线（outline）。这个属性可以在边框盒子外围画出一条线，但这条线不影响盒子的布局，也就是不会影响盒子的宽度和高度。因此，outline常用于调试复杂布局，或者演示布局效果。



盒模型如下图所示：

![BoxModel](https://pvnk1u.github.io/images/BoxModel.PNG)



对元素盒子而言，内边距、边框和外边距不是必需的，因此它们的默认值都为0。不过，用户代码样式表通常会给很多元素添加外边距和内边距。比如，标题通常就会带有一定的外边距，但外边距的值会因浏览器而异。当然，可以覆盖这些样式，要么在自己的样式表里覆盖，要么直接引用重置样式表。



## 盒子大小

默认情况下，元素盒子的width和height属性指的是内容盒子，也就是元素可渲染内容区的宽度和高度。这时候添加边框和内边距并不会影响内容盒子的大小，但会导致整个元素盒子变大。如果想给元素盒子的每一边都添加5像素的边框和5像素的内边距，同时又想让元素盒子的宽度为100像素，则应该像下面这样把内容区宽度设置为80像素。如果这个元素盒子周围还有10像素的外边距，那么整个盒子占据空间的宽度就是120像素（如下图所示）。

```css
.mybox{
	width: 80px;
	padding: 5px;
	border: 5px solid;
	margin: 10px;
}
```

![WidthBoxModelDemo](https://pvnk1u.github.io/images/WidthBoxModelDemo.PNG)



通过修改box-sizing属性可以改变计算盒子大小的方式。box-sizing的默认值为content-box，即前面例子中看到的那样，把宽度值应用给内容区。通过修改box-sizing的值，设置元素的width和height属性，就可以影响元素盒子的不同区域，这对响应式布局非常有用。



如果把box-sizing的值修改为border-box，那么width和height属性的值将会包含内边距和边框。此时，外边距仍然会影响盒子在页面中占据的整体空间，即它的宽度不会算到width中。这样，如下代码可以实现与上面的图一样的布局。

```css
.mybox{
	box-sizing: border-box;
	width: 100px;
	padding: 5px;
	border: 5px;
	margin: 10px;
}
```

![WidthBoxModelDemo](https://pvnk1u.github.io/images/BoxSizingDemo.PNG)

在很多情况下这都很有用，因为很多情况下，这种计算盒子大小的方式更加直观。之所以说这种计算方式“直观“，是因为现实中的盒子就是这样测量的。



如果把CSS中的盒子想象成一个包装箱，那么箱子的四壁就是边框，从视觉上规定了箱子的大小；内边距就是箱子内部的填充层，用于保护箱子里的物品。在箱子宽度既定的情况下，无论是加厚箱壁还是增加填充层厚度，都会挤压最终可用于盛放物品的空间。这样在码放箱子时，不管它们之间空出多大距离（对应CSS中的外边距），都不会影响箱子本身的宽度，以及箱子内部可用的空间。总之，这是一个有实物可以参照的方案。但是浏览器开发人员决定默认采用另一种方式来计算CSS盒模型的宽度，这实际上并不明智。



好在可以通过设置box-sizing属性来覆盖默认行为，简化CSS布局中的一些常用模式。举个例子：

```css
<div class="group">
	<article class="block">
	</article>
</div>
```

默认情况下，如果想让.group中的.block宽度在任何情况下都占其父元素的1/3，可以使用以下规则：

```css
.group .block{
	width: 33.3333%;
}
```

只要不给.block应用内边距，这样写就没问题。但如果给.block添加了内边距，它的宽度就会变成.group元素的1/3外加应用给它的内边距。如果这是一个三栏布局，那么此时添加内边距很可能会破坏原有布局。下图展示了添加内边距前后的不同之处：

![PaddingDiff](https://pvnk1u.github.io/images/PaddingDiff.PNG)



要解决这个问题，可以再增加一个内部元素，然后改为给这个元素添加内边距。或者，可以设置一个不同的box-sizing值，从而修改盒子宽度的计算方式(如下图所示)：

```css
.group .block{
	width: 33.3333%;
	box-sizing: border-box;
    padding: 20px;
}
```

![BorderBoxBlock](https://pvnk1u.github.io/images/BorderBoxBlock.PNG)



此时，无论添加多少内边距和边框，.block的宽度始终保持为其父元素的1/3。



内边距、边框和外边距可以应用于元素的四边，也可以应用于具体某一边。外边距甚至还可以使用负值，使得元素可以在页面中移动。



内边距和外边距的值可以是CSS规范中规定的任意长度单位（px、em或百分比）。其中，使用百分比长度时，有几个问题需要注意。假设还是前面的那个例子，下面代码中的5%到底是什么意思？

```css
.block{
	margin-left: 5%;
}
```

**这里5%指的是父元素.group宽度的5%。如果.group宽度是100像素，那么这里左外边距的宽度就是5像素。**



如果给一个元素的顶部和底部应用内、外边距，那么使用百分比值应该基于元素的高度来计算，对吧？错，因为元素的高度常常不会被声明，而且会因内容多少而差异很大，所以CSS规定，上、下方位的内、外边距，仍然基于包含块的宽度来计算。这里，包含块就是其父元素，但有时候不一定。具体会在后面详细说明。



## 最大值和最小值

有时候，特别是响应式布局中，给一个元素应用min-width和max-width值很有用。因为这样一来，块级盒子就可以默认自动填充父元素的宽度，但不会收缩到比min-width指定的值更窄，或者扩展到比max-width指定的值更宽。



与此类似的是min-height和max-height属性。不过在CSS中，设置任何高度值的时候都应该慎重。这是因为元素的高度通常应该取决于所包含的内容，不需要明确设定。否则，万一内容增多，或者文本字号变大，内容就可能跑到高度固定的盒子之外去。即便出于种种原因，需要明确设定默认高度，也最好使用min-height，因为这个属性允许盒子随内容扩展。



# 可见格式化模型

有了对盒模型的理解，下一步就可以探讨可见格式化及定位模型了。



大家常说p、h1盒article这些元素都是块级元素。意思就是说，它们作为元素，显示为内容块或块级盒子的形式。相对而言，strong、span和time被称为行内元素，因为它们的内容会以行内盒子的形式显示在行内。



可以使用display属性改变生成的盒子类型。换句话说，可以通过把display属性设置为block，让span变得跟块级元素一样。如果把display属性设置为none，还可以让浏览器不为相应的元素生成盒子。如果不生成盒子，那么元素及其包含的内容就不会显示出来，也不会占用文档中的空间。



CSS中有几种不同的定位模型，包括浮动、绝对定位和相对定位。除非特别指定，否则所有元素盒子都会在常规文档流中生成，即position属性的默认值为static。顾名思义，常规文档流中元素盒子的位置，由元素在HTML中的位置决定。



块级盒子会沿垂直方向堆叠，盒子在垂直方向上的间距由它们的上、下外边距决定。



行内盒子是沿文本流水平排列的，也会随文本换行而换行。它们之间的水平间距可以通过水平方向的内边距、边框和外边距来调节。但**行内盒子的高度不受其垂直方向上的内边距、边框和外边距的影响。此外，给行内盒子明确设置高度和宽度也不会起作用。**



**由一行文本形成的水平盒子叫行盒子（line box），而行盒子的高度由所包含的行内盒子决定。修改行盒子大小的唯一途径就是修改行高（line-height），或者给它内部的行内盒子设置水平方向的边框、内边距或外边距。**下图展示了一个段落的块级盒子及其包含的两行文本，其中有一个单词位于显示为行内盒子的strong元素中。

![LineBoxInBlockBox](https://pvnk1u.github.io/images/LineBoxInBlockBox.PNG)



当然，也可以把元素的display属性设置为inline-block。这样设置之后，该元素就会像一个行内盒子一样水平排列。但这个盒子的内部仍然像块级元素一样，能够设置宽度、高度、垂直外边距和内边距。



使用表格相关的标记（table、tr、th等）时，表格本身表现为块级元素，但表格的内容会根据生成的行和列排布。还可以通过设置display属性让非表格元素采用表格的布局方式。只要正确地应用table、table-row和table-cell等值，就可以实现表格布局，无须在HTML标记中使用表格标签。



Flexible Box Layout（也称为Flexbox）和Grid Layout等CSS模块，又进一步扩展了display属性。通常，这些新布局模式会在它们的外部上下文中创建类似块级的盒子，但会为内部显示内容创建新的规则。



在Display Level3模块中，上述外部和内部显示模式的差异正在标准化。在这个模块中，既有显示模式的相关属性和关键字都是可扩展的，从而支持更细粒度的控制。但无论如何，行内盒子和块级盒子仍然是HTML元素默认行为的基础，只是显示当中有了更多选项。





## 匿名盒子

HTML元素可以嵌套，元素盒子当然也可以嵌套。多数盒子都是基于明确定义的元素生成的。不过有一种情况，就算不明确定义元素也会生成块级盒子。比如，像下面这样，在section这个块级元素的开头加入”some text“。此时，”some text“就算没有定义为块级元素，也会被当成块级元素。



```html
<section>
	some text
	<p> some more text</p>
</section>
```

这种情况下，这个盒子被称为匿名块盒子，因为这个盒子并不与任何特定的元素相关。



类似的情况也存在于块级元素内部的文本级行盒子。假设有一个段落中包含三行文本，这三行文本的每一行都构成了一个匿名行盒子。除了使用.first-line伪元素来添加有限的排版和颜色相关的样式之外，不能直接给匿名块盒子或匿名行盒子应用样式。关键要知道，在屏幕上看到的一切都会从属于某个盒子。



## 外边距折叠

常规块盒子有一种机制叫作外边距折叠。外边距折叠的概念很简单，但实践中常常给布局网页带来困惑。**简而言之，垂直方向上的两个外边距相遇时，会折叠成一个外边距。折叠后外边距的高度等于两者中较大的那一个高度。**



如下图所示，当两个元素垂直堆叠时，上方元素的下外边距会与下方元素的上外边距相折叠。

![FoldableMargin](https://pvnk1u.github.io/images/FoldableMargin.PNG)



在一个元素嵌套着另一个元素的情况下，假设没有内边距或边框来分隔外边框，它们的上、下外边距也会折叠。



![FoldableMarginInBox](https://pvnk1u.github.io/images/FoldableMarginInBox.PNG)



乍一看，这种情况不太正常，但事实还不止如此：甚至同一个元素的外边距都能折叠。假设有一个空元素，只有外边距而没有边框或内边距。此时，上外边距与下外边距接触，结果也会折叠：

![FoldableMarginInEmpty](https://pvnk1u.github.io/images/FoldableMarginInEmpty.PNG)



更进一步，如果折叠后的外边距又碰到了其他元素的外边距，还会继续折叠。

![ContinueFoldMargin](https://pvnk1u.github.io/images/ContinueFoldMargin.PNG)



这就是再多的空段落也只会占用一小块空间的原因：它们的外边距都折叠成一个小外边距了。



外边距折叠好像很奇怪，实际上却很有用。以一个包含几段文本的页面为例：

![ReasonOfMargenFold](https://pvnk1u.github.io/images/ReasonOfMargenFold.PNG)

这一段上方的间距等于这一段的上外边距。如果没有外边距折叠，则后续所有段落的间距，都是相邻的上、下外边距之和。结果就是段间距是上页边距的两倍。有了外边距折叠，段间距才会与页边距相等。



外边距折叠只会发生在文档常规文本流中块级盒子的垂直方向上。行内盒子、浮动盒子或绝对定位盒子的外边距不会折叠。



## 包含块

知道什么决定一个元素的包含块非常重要，前面的例子中，将内边距和外边距的值设置为百分比，包含块就是这些百分比值的计算依据。



确定元素的包含块，要看元素是如何定位的。**如果元素的定位方式为静态定位（即不指定position属性的值）或相对定位，则其包含块的边界就计算到一个最近的父元素，该元素的display属性值必须能够提供类似块级的上下文，如block、inline-block、table-cell、list-item等。**



**默认情况下，width、height、margin和padding的值为百分比时，就以该父元素的尺寸为计算依据。如果当前元素的定位模型改成了absolute或fixed，那么计算依据就会发生变化。**接下来逐个讨论不同的定位模型，以及如何确定与之对应的包含块。



## 相对定位

把一个元素的display属性设置为relative，该元素仍然会呆在原来的地方。但此后，可以通过设置top、right、bottom和left属性，使该元素相对于初始位置平移一段距离。比如设置top属性为20像素，该元素就会相对于其初始位置垂直向下平移20像素。而设置left属性为20像素，则会将该元素向右移动20像素，其左侧会出现空白。

```css
.mybox{
	position: relative;
	left: 20px;
	top: 20px;
}
```

![relative](https://pvnk1u.github.io/images/relative.PNG)



无论是否位移，相对定位的元素仍然会在文档流中占用初始的空间。因此，这样平移元素会导致遮挡其他元素。



## 绝对定位

相对定位事实上是常规文档流定位模型的一部分，因为元素还是相对于它在常规流中的初始位置来定位。绝对定位则会把元素拿出文档流，因此也就不会占用原来的空间。与此同时，文档流中的其他元素会各自重新定位，彷佛绝对定位的那个元素没有存在过一样。

![AbsolutePosition](https://pvnk1u.github.io/images/AbsolutePosition.PNG)



**绝对定位元素的包含块是距离它最近的定位祖先，也就是display属性设置为static之外任意值的祖先元素。如果没有这么一个定位祖先，那么它就相当于文档的根元素即html元素定位。文档的根元素也叫作起始包含块。**



与相对定位的盒子类似，绝对定位的盒子也可以相对于其包含块向上、下、左、右方向平移。平移绝对定位的元素提供了极大的灵活性，因为可以把元素移动到页面的任意位置。



**绝对定位的盒子是脱离了常规文档流的，因此可能会遮挡页面上的其他元素。为了控制这些盒子层叠的次序，可以设置一个叫z-index的属性。z-index的属性值越大，盒子在层叠中的次序就越靠近用户的眼睛。**



尽管绝对定位对于在页面上任意摆放元素非常有用，但近来已经很少被用来构建整体布局了。绝对定位的盒子脱离了常规文档流，因此很难用它们创建随视口宽度和内容长度变化而变化的自适应或者响应式布局。web技术的特点决定了不太可能指定元素在页面上的确切位置和大小。绝对定位在整体布局上几乎没人用了。



## 固定定位

固定定位是由绝对定位衍生出来的，不同之处在于，固定定位元素的包含块是视口（viewport）。因此，固定定位可以用来创建始终停留在窗口相同位置的浮动元素。很多网站都用这个技术让导航区始终保持可见，有的固定侧栏，有的固定顶栏。这样能确保网站的可用性，因为用户不必再费事寻找了。



## 浮动

另一种可见格式化模型是浮动模型。浮动盒子可以向左或向右移动，直到其外边沿接触包含块的外边沿，或接触另一个浮动盒子的外边沿。浮动盒子也会脱离常规文档流，因此常规流中的其他块级盒子的表现，几乎当浮动盒子根本不存在一样。



如下图所示，向右浮动Box1时，Box1会脱离文档流并向右移动，直至其右边沿接触包含块的右边沿。同时，Box1的宽度也会收缩为适应于其中内容的最小宽度，除非通过width或min-width/max-width明确设置其宽度。



![FloatBox](https://pvnk1u.github.io/images/FloatBox.PNG)



如下图所示，向左浮动Box1时，它脱离文档流并向左浮动，直至其左边接触包含块的左边沿。Box1已经不在文档流中，因此不会再占用空间，这导致它浮于上方，遮住了Box2。如果向左浮动全部3个元素，Box1会向左移动，直到接触其包含块；另外两个盒子也向左移动，直到接触自己前面的浮动盒子。

![MoreFloatBox](https://pvnk1u.github.io/images/MoreFloatBox.PNG)



如果包含元素太窄，无法容纳所有浮动元素水平排列，则后面的浮动元素会向下浮动（如下图）。如果浮动元素高度不同，则后面的浮动元素在向下移动时可能会“卡”在前面的浮动元素右侧。

![FloatBoxToBottom](https://pvnk1u.github.io/images/FloatBoxToBottom.PNG)



**行盒子与清除**

前面说到，浮动元素会脱离文档流，因此不会再像非浮动元素一样影响其他元素。实际上，严格来讲并非如此。如果浮动元素后面跟着的是常规文档流中的元素，那么这个元素的盒子就会当浮动元素不存在一样，该怎么布局就怎么布局。但是，这个元素盒子中的文本内容则会记住浮动元素的大小，并在排布时避开它，为其留出相应的空间。从**技术上来讲，就是跟在浮动元素后面的行盒子会缩短，从而为浮动元素留空，造成文本环绕浮动盒子的效果。事实上，浮动就是为了在网页中实现文本环绕图片的效果而引入的一种布局模型。**如下图所示：

![DocAroundFloatBox](https://pvnk1u.github.io/images/DocAroundFloatBox.PNG)



要阻止行盒子环绕在浮动盒子外面，需要给包含行盒子的元素应用clear属性。clear属性的值有left、right、both和none，用于指定盒子的哪一侧不应该紧挨着浮动盒子。很多人认为clear属性只是简单地删除几个用于抵消前面浮动元素的标记，事实却没有这么简单。清除一个元素时，浏览器会在这个元素上方添加足够大的外边距，从而将元素的上边沿垂直向下推移到浮动元素下方(如下图所示)。因此，如果给“已清除的”元素添加外边距，那么除非外边距的值超过浏览器自动添加的值，否则不会看到什么效果。



![ClearFloat](https://pvnk1u.github.io/images/ClearFloat.PNG)



浮动元素除了会导致后面的行盒子缩短，从而造成文本环绕效果外，不会对周围的元素有任何别的影响，毕竟它已经脱离了文档流。但清除一个元素本质上会为所有前面的浮动元素清理出一块垂直空间。这就为使用浮动布局创造了条件，因为周围的元素可以为浮动的元素腾出地方来。



下面看看怎么利用浮动实现一个简单的布局。假设想把一张图片浮动到一个标题左边，把一小段文本浮动到标题右边。这种布局一般叫作“媒体对象”。因为左侧放一个媒体（如插图、图片或视频）、右侧放一段说明文字是一种常见的布局模式。另外，如果希望这张图片及右侧的文本被包含在另一个有背景颜色和边框的元素中。那么可以写出如下规则：

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>FloatDemo</title>
<style>
	.media-block{
		backgroud-color: gray;
		border: solid 1px black;
	}

	.media-fig{
		float: left;
		width: 30%; /* 给文本留出70%的宽度 */
	}

	.media-body{
		float:right;
		width: 65%; /* 左边再留出一点空隙来 */
	}
</style>
</head>
<body>
    <div class="media-block">
		<img class="media-fig" src="/img/pic.jpg"  alt="The pic" />
		<div class="media-body">
			<h3>Title of this</h3>
			<p>Brief description of this</p>
		</div>
	</div>
</body>
</html>
```

不过，浮动的元素会被拿出文档流，因此类为.media-block的div不会占用空间：它只包含浮动的内容，因此无法在文档流中为它生成高度。怎样才能让这个元素从视觉上也包住浮动元素？需要在这个元素内部某处应用clear。这样就会像前面看到的一样，在清除的元素上方创造出足够的垂直外边距，从而为包住浮动元素创造出空间（如下图）。然而，由于这个例子中没有用来清除的元素，需要在结束后的div标签前额外加一添加一个空元素，然后清除该元素：

```html
/* 后补的CSS */
.clear{
	clear: both;
}

<div class="media-block">
	<img class="media-fig" src="/img/pic.jpg" alt="The pic" />
	<div class="media-body">
		<h3>Title of this</h3>
		<p>Brief description of this</p>
	</div>
	<div class="clear"></div> <!-- 额外添加的空div -->
</div>
```



![ClearFloatToAround](https://pvnk1u.github.io/images/ClearFloatToAround.PNG)

这样就实现了想要的布局，但也引入了“多余”的标记。有时候可能会有现成的元素用于清除，但有时候就不得不像这里一样，额外加入与布局没什么关系的标记。其实还有更好的方法。



要改进这个例子，可以使用:after伪类来模拟额外的清除元素。把下面的规则应用给包含浮动元素的容器div，就会在它内部的末尾生成一个盒子，并在这个盒子上应用清除规则：

```css
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>FloatDemo</title>
<style>
	.media-block{
		backgroud-color: gray;
		border: solid 1px black;
	}
	
	.media-fig{
		float: left;
		width: 30%; /* 给文本留出70%的宽度 */
	}

	.media-body{
		float:right;
		width: 65%; /* 左边再留出一点空隙来 */
	}
	
	.media-block:after {
      content: '';
      display: block;
      clear: both;
    }
	
</style>
</head>
<body>
    <div class="media-block">
		<img class="media-fig" src="./BoxModel.PNG"  alt="The pic" />
		<div class="media-body">
			<h3>Title of this</h3>
			<p>Brief description of this</p>
		</div>
	</div>
</body>
</html>
```



## 格式化上下文

当元素在页面上水平或垂直排布时，它们之间如何相互影响，CSS有几套不同的规则，其中一套规则叫作格式化上下文。前面已经介绍了行内格式化上下文的一些规则。比如，垂直外边距对于行内盒子没有影响。类似的，有的规则适用于块级盒子的叠放，比如上一节对应的外边距折叠。



此外，**有些规则规定了页面必须自动包含突出的浮动元素（否则浮动元素中的内容可能会跑到可滚动区域之外），而且所有块级盒子的左边界默认与包含块的左边界对齐（如果文字顺序是从右向左，那么与包含块的右边界对齐）。这组规则就是块级格式化上下文。**



还**有些规则允许元素建立自己内部的块级格式化上下文**，包括：

- display的属性值设置为inline-block或table-cell之类的元素，可以为内容创建类似块级的上下文。
- float属性值不是none的元素。
- 绝对定位的元素。
- overflow属性值不是visible的元素。



前面说过，块边界接触其包含块边界的规则同样适用于前面是浮动元素的内容。浮动元素从页面流中移出后，通过触发其后的元素中行盒子的缩短行为，制造了为自身腾出四周空间的视觉效果。而其后的元素仍然会按照需要，在浮动元素下方拉伸。



**当一个元素具备了触发新块级格式化上下文的条件，并且挨着一个浮动元素时，它就会忽略自己的边界必须接触自己的包含块边界的规则。此时，这个元素会收缩到适当大小；不仅行盒子如此，所有盒子都如此。**利用这一点，可以通过更简单的规则实现前面的媒体对象组件：

```html
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Media Object, utilizing the formatting context</title>

  <style type="text/css" media="screen">
    .media-block {
      background-color: gray;
      border: solid 1px black;
    }
    .media-fig {
      float: left;
      margin-right: 5%;
    }
    
    .media-body, .media-block {
      overflow: auto; /* 1 */
    }
  </style>
</head>
<body>
  <div class="media-block">
    <img class="media-fig" src="img/pic.png" alt="The pic" />
    <div class="media-body">
      <h3>Title of this</h3>
      <p>Brief description of this</p>
    </div>
  </div>
</body>
</html>
```

**给.media-block和.media-body元素都设置了overflow: auto;之后，就为它们创建了新的块级格式化上下文。**这样就实现了目标（如下图）：

1. **不用设置清除规则，就可以让.media-block包住浮动的照片，因为块级格式化上下文自动包含浮动。**
2. **顺带着，可以放弃给.media-body声明宽度和浮动。这是因为它会自动调整以适应浮动元素旁边的剩余空间，并确保挨着图片的一边是直的。如果没有通过给.media-body设置overflow:auto，则.media-body就没有新的格式化上下文，此时如果.media-body的文本比较多，那么位于浮动.media-fig下方的盒子都会伸长，最终填满图片下方的空间。**



尽量基于简单且可预测的行为来创建布局，这样可以降低代码复杂度，并提高布局稳健性。因此，知道什么时候可以使用这个技术，以避免浮动和清除元素之间的复杂交互，可以说是一件可喜的事。





![FomattedContext](https://pvnk1u.github.io/images/FomattedContext.PNG)



如上图所示，如果只浮动.media-fig且文本足够多，就会有一些文本环绕到图片下方。而创建一个新的块级格式化上下文会强迫.media-body收缩。





# 其他CSS布局模块

目前为止，已经介绍了CSS可见格式化模型的基础以及大部分公共的内容。这一节简单介绍其他相关内容。



对于CSS这种视觉表现语言来说，稳健又灵活的布局无论如何都是需要的。虽然道理显而易见，但这种模型的诞生却并不容易。过去曾想方设法地利用这门语言中可用的特性来达成目标，哪怕那些特性并不好用。比如最早曾使用表格布局，但问题是代码臃肿、语义不当。近来又在使用浮动和绝对定位，但这些技术同样也并非为页面布局而设计。无论是表格还是浮动与定位，都有非常严重地局限性。使用它们只是不得已的选择。



可喜的是，最近出现了一些专门针对创建灵活、稳健页面布局的CSS模块。


## 弹性盒布局

弹性盒布局，常被称为Flexbox，是CSS3新引入的一种布局模型。Flexbox支持对子元素水平或垂直布局，以及设置这些子元素的大小、间距和对齐方式。此外，Flexbox还支持改变元素渲染到页面上的次序，可以跟它们在HTML中的次序不同。作为CSS常规流模型（行内和块）的升级版，无论是调整内容本身还是适应内容大小，Flexbox都做到了既精确又灵活。



## 网格布局

网格布局是CSS最早成熟的高层布局工具，目标是取代浮动和定位元素的布局方式。网格布局实现了源代码次序的完全分离，从内容结构和个别模块的表现中抽象出了网格系统。Flexbox关注“微观”，而网格系统关注“宏观”，二者正好互补。



## 多栏布局

多栏布局模块的用意很明确，就是实现内容的多栏布局。比如，要排成像报纸那样的多栏样式。可以先指定栏数，也可以先指定每一栏的宽度，然后让浏览器根据可用宽度自动确定栏数。当然，还可以控制栏间距，并在其中应用类似边框的视觉效果。





