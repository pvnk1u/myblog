---
title: "精通CSS读书笔记(6)——内容布局" 
date: 2023-06-05T23:28:39+08:00
draft: false
tags: ["web","css"]
categories:
  - "web"
  - "css"
toc: true
---





网页是由不同内容块构成的：标题、段落、链接、列表、图片、视频等等。这些元素可以按照主题组织起来，比如一个标题，几段文本，外加一张图片就是一篇新闻报道。通过控制每个组件内部元素的位置、大小、顺序，就可以更好地传达它们的功能与含义。



所有内容块会进一步组织成整个页面的布局。下一章将会讲到如何系统化地布局页面。本章仍然聚焦于个别的内容块，从而深入理解如何对每个内容块进行布局。



之前大致讲过使用定位和浮动来实现布局，这两种手段各有千秋。此外，也可以使用表格显示模式和行内块来实现布局，当然也各有各的优缺点。CSS新增的Flexible Box Layout Module（或Flexbox）为内容块提供了一大批顺序、方向、对齐及尺寸相关的属性。Flex是非常强大的布局功能，本章会详细介绍。



# 定位

定位并不适合于总体布局，因为它会把元素拉出页面的正常流。反过来看，这也正是定位在CSS中之所以重要的原因，接下来将简单探讨一下定位在哪些情况下最合适。



以下是对定位内容的简单总结：

1. 元素的初始定位方式是静态定位（static），意思是块级元素垂直堆叠。
2. 可以把元素设置为相对定位（relative），然后可以相对于其原始位置控制该元素的偏移量，同时又不影响其周围的元素。**与此同时，这也为该元素的后代元素创造了定位上下文。**这一点也是相对定位真正的用处。以前，在一些古老的布局技巧中，经常要偏移元素，当然现在已经很少这样了。
3. 绝对定位（absolute）支持精确定位元素，相对于其最近的定位上下文：或者是其非静态定位的祖先元素，或者是HTML元素。绝对定位的元素会脱离页面流，然后再相对于其定位上下文进行定位。默认情况下，它们会被浏览器定位于之前静态定位时所处的位置但不会影响周围的元素。然后，可以相对于定位上下文来改变它们的位置。
4. 固定定位（fixed）与绝对定位基本类似，只不过**定位上下文被自动设置为浏览器视口。**



## 绝对定位的应用场景

绝对定位非常适合创建弹出层、提示和对话框这类覆盖于其他内容之上的组件。它们的位置可以通过top、right、bottom和left属性控制。关于绝对定位，了结以下知识可以写出更高效的代码。



1. 利用初始位置

   比如有一篇介绍太空飞船的文章，想在文章上添加一些行内的评注。这些评注最好以气泡图的样式显示在文章外部的空白区域，如下图所示。

   ![Spaceship](https://pvnk1u.github.io/images/Spaceship.PNG)

   每个评注组件都是一个aside组件，实际位置在它们指向的段落后面：

   ```html
   <p>This is	a fake article[...]</p>
   <aside class="comment">I`ve never done this. Is that really true?</aside>
   <p>You may think[...]</p>
   ```

   为了让评注显示在段落之后，需要使其绝对定位。而我们不必为了在垂直方向上准确的定位它们而给出确切的上偏移量。

   

   **绝对定位的元素默认会待在自己静态定位时的地方**，因此第一步是让评注显示在其初始位置。

   ```css
   .comment{
   	position: absolute;
   }
   ```

   添加这段CSS代码之后，aside元素将会变成绝对定位，即脱离页面流。这样一来，原本会跟在p元素文本段落之后看起来像是单独段落的aside内的内容将会出现在再往后的第二段p元素的上方，导致显示重叠。

   

   接下来需要把评注向左和向上偏移，把它定位到之前段落的旁边。这听起来像是要使用相对定位，但元素不能同时既是绝对定位又是相对定位。如果此时使用方向性偏移属性（top、right、left和bottom），那就既要用到定位上下文，又要设置确定的偏移量。好在不用这么麻烦，在这里完全可以通过负外边距来移动元素：

   ```css
   .comment{
   	position: absolute;
   	width: 7em;
   	margin-left: -9.5em;
   	margin-top: -2.5em;
   }
   ```

   在CSS中，负外边距是完全有效的，它们有如下有趣的行为。

   - 左边或上边的负外边距会把元素向左或向上拉，盖住其旁边的元素。
   - 右边或下边的负外边距会把相邻元素向左或向上拉，盖住设置了负外边距的元素。
   - 在浮动的元素上，与浮动方向相反的负外边距会导致浮动区域缩小，使得相邻元素盖住浮动的元素。而与浮动方向相同的负外边距会在该方向上把浮动的元素向外拉。
   - 给未声明宽度的非浮动元素应用负外边距时，左、右负外边距会向外拉伸元素，导致元素扩张，有可能盖住相邻元素。

   对评注气泡组件而言，使用左和上负外边距把元素拉到位的做法，与使用相对定位很相似。

2. 创建三角形

   在评注气泡组件中，指向前面段落的小三角形又相对于评注气泡进行了绝对定位。它是通过伪元素创建的，使用了一种很古老的基于边框的技巧。

   相关代码如下：

   ```css
   .comment:after {
     position: absolute;
     content: '';
     display: block;
     width: 0;
     height: 0;
     border: .5em solid #dcf0ff;
     border-bottom-color: transparent;
     border-right-color: transparent;
     position: absolute;
     right: -1em;
     top: .5em;
   }
   ```

   这里创建了一个0像素的块，其边框是0.5em，而且边框也只显示左、上边框。结果浏览器就只渲染出一个三角形。不用图片一样可以创造出三角形来！然后再把三角形定位到评估气泡的右上角位置。这里通过将border-bottom-color和border-right-color的值设置为transparent透明进而实现右半下角透明的效果（进而只剩下左上半角的图形）。

3. 利用偏移实现自动大小

   从另一个角度看，有必要知道：**在绝对定位的情况下，如果声明了多个或所有偏移值，那么结果会怎么样。如果没有显式声明元素大小，那么绝对定位元素的大小由自身包含内容的多少来决定。如果相对于定位上下文的各个边声明偏移值，那么元素会被拉伸以满足设定的规则。**

   

   比如，如果希望让某元素总是与其外部元素保持一定距离，但又不给任何元素设定大小。如下图所示，一张图片上有一个包含文本的元素。

   ```html
   <header class="photo-header">
   	<img src="images/big_spaceship.jpg" alt="An artist`s mockup of the "Dragon" spaceship">
   	<div class="photo-header-plate">
   		<h1>SpaceX unveil the Crew Dragon</h1>
   		<p>Photo from SpaceX on <a href="https://www.flickr.com/photos/spacexphotos/16787988882/" >
   		Flickr</a></p>
   	</div>
   </header>
   ```
   
   ![SpaceX](https://pvnk1u.github.io/images/SpaceX.PNG)



**假设不想给这个包含标题的盒子设定明确的宽度，那么可以只指定其右、下、左边的偏移，让它自己去计算上空距离**：

```css
.photo-header{
	position: relative;
}

.photo-header-plate{
	position: absolute;
	right: 4em;
	bottom: 4em;
	left: 4em;
	background-color: #fff;
	background-color: rgba(255,255,255,0.7);
	padding: 2em;
}
```

**无论图片多大，标题区始终都会位于距离底边及左、右两边4em的地方，而且会在标题折行的情况下自动调整高度，从而适应不同的屏幕大小。**



## 定位与z-index：堆叠内容的陷阱

要用好定位，还有一个重点技术必须掌握，那就是z-index，也就是堆叠元素的次序。基本原理：**静态定位（static）以外的元素会根据它们在代码树中的深度依次叠放，就像打扑克牌一样，后发的牌会压在先发的牌上面。它们的次序可以通过z-index来调整。**



设置了z-index的元素，只要值是正值，就会出现在没有设置z-index的元素上方。尚未设置z-inde的元素在z-index值为负的元素上方。



除了z-index，还有其他影响元素堆叠次序的因素。这里也有一个概念，叫堆叠上下文。就像一盒扑克牌，每张牌本身也是一个上下文（牌盒），而牌只能相对于当前的牌盒排定次序。有一个根堆叠上下文，所有z-index不是auto的定位元素都会在这个上下文中排序。随着其他上下文的建立，就会出现堆叠层级。



堆叠上下文是由特定属性和值创建的。比如，任何设定了position: absolute及值不是auto的z-index属性的元素，都会创建一个自己后代元素的堆叠上下文。



在一个堆叠上下文内部，无论z-index值多大或多小，都不会影响其他堆叠上下文，毕竟不能相对于别的堆叠上下文重新排序。



如下图所示：

![OpacityAndZIndex](https://pvnk1u.github.io/images/OpacityAndZIndex.PNG)

**容器A、B、C和D都是绝对定位的，其中C是B的子元素。容器C和D设置了z-index，但由于容器B的opacity值小于1，所以它又创建了一个新的独立的堆叠上下文。于是，就算C的z-index的值再大，它也不会跑到D的上方。**



**设置小于1的opacity值也可以创建新的堆叠上下文。opacity小于1的元素需要独立渲染（包括它的所有后代元素），然后再放到页面上。这样就可以保证在把它们放到页面上时，原有的元素不会与半透明的元素发生交错。后面会有这个例子及其他类似的例子，比如transform和filter属性，也会触发创建新的堆叠上下文。**



# 水平布局

通常，页面会随内容增加沿垂直方向扩展。后来添加的任何块容器（div、article、h1-h6等等）都会垂直堆放起来，因为**块级元素的宽度是自动计算的**。**因此，在需要给内容块设置明确宽度，并让它们水平排列时，就会出现问题。**



使用浮动来实现小型“媒体组件”布局是一种基础的组件模式，即组件一边是图片（或其他媒体），另一边是文本，“左边是这个，右边是那个，二者相互关联“。很多网站都在使用这种模式。如下图所示：

![MediaComponent](https://pvnk1u.github.io/images/MediaComponent.PNG)

**除此之外，还有很多通用模式的组件，可见于各类网站。其中很多都涉及水平布局。为此，CSS引入了Flexbox来专门解决水平布局问题（以及其他问题）**，但在得到浏览器完全支持之前，可能还要借助浮动、inline-block显示，或者表格显示模式，才能完美实现水平布局。



## 借助浮动

