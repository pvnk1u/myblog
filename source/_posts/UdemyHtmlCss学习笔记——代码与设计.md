---
title: "UdemyHtmlCss学习笔记——代码" 
date: 2023-11-21T23:32:39+08:00
draft: false
tags: ["web","html","css"]
categories:
  - "web"
  - "html"
  - "css"
toc: true
---

# H5

1. 使用`strong`元素取代`b`元素进行加粗显示
2. 使用`em`元素取代`i`元素进行斜体显示



## 语义化元素

- **header**
- **nav**
- **section**
- **article**
- **aside**
- **figcaption**
- **figure**
- **footer**





# CSS

## 默认样式

很多HTML元素本身都带有默认样式，默认样式定义在`用户代理样式表(user agent stylesheet)`中。

## 字体

`font-family`为`sans-serif`代表无衬线字体，`serif`代表有衬线字体，有无沉陷的区别体现在文字的边角上是否有相应多出来的边缘线。无衬线字体更加简洁现代。



## CSS选择器

1. 后代选择器

   ```css
   header p{
   		
   }
   ```

2. Id、Class选择器

   ```css
   #name{
   	
   }
   
   .class{
   	
   }
   ```

3. 元素选择器

   ```css
   p{
   	
   }
   
   a{
   
   }
   ```

4. 通用选择器

   ```css
   /**
   通用选择器
   */
   *{
   
   }
   ```
   
   **实际上，通用选择器是非常有用的，因为很多HTML元素都具有默认样式，如margin、padding等属性都有默认值。此时，为了方便对页面元素进行排版，便可以使用通用选择器直接指定所有元素的margin、padding值为0，这样后续开发时，HTML元素便不会受到默认样式的影响，因为通用选择器的优先级很低，可以很容易地被其他选择器设置的样式覆盖。**

## 尺寸

在`CSS`中可以通过`height`和`width`设置元素的高度和宽度。

对图像设置尺寸时，需要注意宽高度需要和原图片的宽高度保持一致，否则图片将会失真，可以在对宽高度中的其中一个进行了设置后，对另外一个属性使用`auto`属性自动适应。另外，如果使用百分比(如50%)设置元素宽度时，意味着元素的宽度将会是元素所在父元素的一半宽度，这对于`响应式`非常有用。



## 颜色

### RGB

每种颜色都可以通过`RED`、`GREEN`、`BLUE`三种颜色的组合来呈现，这就是RGB颜色表示法。这三种基础颜色的取值范围可以从0~255不等，也就是说可以通过这三种基础颜色的组合呈现出一千六百多万种颜色。

当`RED`、`GREEN`、`BLUE`三种颜色中的的某一个值分别为最大值，而另外两个值为0时，则呈现出纯粹的对应颜色。

![RGB](https://cdn.britannica.com/89/234589-050-0E6E9D4B/color-wheel-additive.jpg?w=400&h=300&c=crop)

### CSS颜色表示法

在CSS中有两种颜色表示法：

1. RGB/RGBA表示法

   通过使用`RGB`函数指定颜色，例如`rgb(0,255,255)`。

   当需要指定颜色透明度的时候可以使用`RGBA`,`A`代表`Alpha`，例如`rgba(0,255,255,0.3)`，第四位值取值范围为0~1，取值越小则越透明，越大则越明显。

2. 十六进制表示法

   十六进制表示法不使用RGB的0~255的表示法，而是使用0~FF的表示法，FF和255一样。例如`#00ffff`，当十六进制表示法中的某两位相同时，可以使用速记法表示，例如`#00ffff`可以表示为`#0ff`。

实践中大多使用十六进制表示法，如果需要透明度，则使用`RGBA`表示法。



### 灰色

在`RGB`表示法中，当光谱中的三个颜色相同时，将会得到灰色。当三个光谱值为最大值255时，得到白色，当三个值为最小值0时，得到黑色。也就是说正好有256种灰色值可以选择。



## 伪类

1. first-child

   ```css
   /** 
   当一个li元素所在父元素下的第一个子元素是li元素时，这个第一个子元素(li元素)将被选中。
   如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中
   */
   li:first-child{
   	
   }
   ```

2. last-child

   ```css
   /** 
   当一个li元素所在父元素下的最后一个子元素是li元素时，这个第一个子元素(li元素)将被选中。
   如果一个li元素所在父元素下的第一个子元素不是li元素时，则这个li元素所在父元素下的子li元素都将不会被选中
   */
   li:last-child{
   	
   }
   ```

3. nth-child()

   ```css
   /**
   当一个li元素所在父元素下的第偶数个元素是li元素时，这个元素将会被选中，如果第偶数个元素不是li元素则不会被选中
   */
   li:nth-child(even){
   	
   }
   ```

   更多用法参考 [MDN nth-child()](https://developer.mozilla.org/zh-CN/docs/Web/CSS/:nth-child)

4. 链接伪类

   - `a:link`

     选中所有具有`href`属性的`a`元素，如果没有`href`属性代表不是真正的链接，所以不算是`link`，`a:link{}`中的`css`规则如果与`a{}`中设置的规则相同时，生效的将是`a:link{}`中设置的规则。

   - `a:visited`

     设置访问过的链接的样式，大多数现实情况下与`a:link{}`中的样式相同。

   - `a:hover`

     设置鼠标在`a`链接上悬停时的样式，

   - `a:active`

     设置实际点击`a`链接时的链接的样式

   需要特别注意的是，在实际使用时，总是应该按照这个顺序定义链接在不同情况下的样式，即`L V H A`。

   在浏览器的开发者工具中，可以手动选中链接伪类以进行链接样式调试。



## CSS三大特性

### CSS选择器优先级

当一个元素被多个选择器共同指定样式规则时，其中的所有样式都将被应用，但是可能会存在一个元素对应的多个选择器中存在相同CSS属性的情况，如下所示：

```html
<p id="author-text" class="author">
	Some Text
</p>
```

```css
.author{
	font-style: italic;
	font-size: 18px;
}

#author-text{
	font-size: 20px;
}

p,
li{
	font-family: sans-serif;
	color: #444;
	font-size: 22px;
}
```

在这段代码中，都对指定的`p`元素设置了`font-size`属性，这种情况下会根据CSS选择器的优先级来确定哪个选择器中的样式得到应用，优先级顺序如下（从高到低）：

1. !important

   使用`!important`声明的样式具有最高优先级，但是通常不应该使用，只应该在必要时作为最后的手段用来解决CSS中的冲突。

2. 内联样式（不应该使用）

   ```css
   <p style="font-size:18px">
   	Some Text
   </p>
   ```

3. ID选择器(#)

   如果有多个ID选择器对同一个元素设置了样式，则最后被定义的选择器生效

4. Class/伪类选择器

   同样的，当有多个class选择器时，最后被定义的选择器生效

5. 元素选择器

   同样的，当有多个元素选择器时，最后被定义的选择器生效

6. 通用选择器（优先级最低）

   ```css
   /**
   通用选择器
   */
   *{
   
   }
   ```

`VS Code`中当鼠标悬浮在CSS选择器上时，`VS Code`会自动计算并显示出对应选择器的生效优先级权重`Selector Specificity`，其存在三个值，例如(1,0,0)，值越大的选择器，其定义的样式生效的优先级越高。



在实际开发中，应尽量避免某个元素的相同属性被定义在其多个选择器中，这样会使选择器及其中定义的样式变得非常混乱难以理解。



### 继承性

给父元素设置一些属性，子元素也可以使用，这个我们就称之为继承性。

1. 并不是所有的属性都可以继承, 只有以color/font-/text-/line-/letter-/list-开头的文本属性才可以继承。
2. 在CSS的继承中不仅仅是直接子元素可以继承, 只要是后代都可以继承
3. 继承性中的特殊性
   - a标签的文字颜色和下划线是不能继承的
   - h标签的文字大小是不能继承的
4. 元素继承来的样式是优先级最低的。

可以通过通用选择器来为所有元素设置统一的不会被继承的样式：

```css
*{
	
}
```



## CSS盒子模型



### 盒子模型组成

盒子模型是CSS最基本的模型，盒子模型定义了元素如何显示在网页上以及元素的大小。每个页面元素都可以看作是一个矩形框，每个框都可以有内容（content）、内部的填充（padding）、内部的边框（border）、外部的边界（margin）等部分。

1. 内容（content）

   这是页面元素的实际内容，它可以是文本/图像/表格/视频等各种内容，CSS属性中的高度`height`、宽度`width`属性所指的宽高度就是指的内容区的宽高度。

2. 边框（border）

   在元素内容之外的区域内，可以指定元素的边框（包括宽度、样式、杨色等样式），需要注意的是，边框依然属性元素内的区域。

3. 填充（padding）

   在元素内容向外、边框向内的区域，是元素的填充，填充围绕着元素内容。和边框（border）一样，padding也依然是在元素内部。 填充（padding）本质上是可以在元素内部创建的独立于元素内容之外的空白空间。

4. 外边距（margin）

   在边框（border）之外的区域就是外边距 （margin），和填充（padding）不同的是，外边距（margin）已经不是在元素内部了，外边距描述的是多个元素之间的空间。



对于页面元素的这四个部分来说，其中前三个部分内容（content）、边框（border）、填充（padding）加起来的区域是元素的可见部分（也可称为填充区域）。需要特别注意的是，虽然元素的实际内容（文字、图像、视频等）只会显示在内容（content）区域中，但是如果元素设置了`background`、`background-color`等背景属性时，这些背景属性所应用的范围并不是内容（content）区域，而是整个元素的可见部分（填充区域）。



对于边框（border）、填充（padding）、外边距（margin）可以有多种方式指定上下左右四个方向的值，比如：

```css
/**
指定元素的上下左右的填充都是20个像素
*/
.class{
	padding: 20px;
}

/**
指定元素的上下填充都是20个像素、左右的填充是40个像素
*/
.class{
	padding: 20px 40px;
}

/**
指定元素的
    上填充为25px
    右填充为50px
    下填充为75px
    左填充为100px
*/
.class{
	padding:25px 50px 75px 100px;
}

/**
指定元素的
    上填充为25px
    左右填充为50px
    下填充为75px
*/
.class{
	 padding:25px 50px 75px;
}
```



**对于margin属性，特别需要注意的一点是：如果两个相邻元素均设置了彼此对向方向上的margin属性值，则这两个相邻元素的外边距值不是其分别设置的外边距值之和，而是两个外边距值中的最大值。这种现象被称为边缘坍陷。**



### 盒子模型计算

默认盒子模型下，元素在页面上实际显示时所占用的宽度和高度计算方式由内容区域（content）、填充（padding）、边框（border）三部分得出，元素内容（content）的高度和宽度可以通过height和width属性指定，如果不指定的话，浏览器将根据实际内容自动计算得出，但是这个内容区域的高度和宽度并不是元素最终在页面上显示时的高度和宽度，真正的宽高度计算方式如下：

1. 真正的元素宽度

   左边框(left border) + 左填充（left padding） + 元素内容区域宽度（width） + 右填充（right padding） + 右边框（right border）

2. 真正的元素高度

   顶部边框(top border) + 顶部填充（top padding） + 元素内容区域高度（height） + 下填充（bottom padding） + 底部边框（bottom border）



### 盒子模型类型

默认的盒子模型为`box-sizing: content-box;`，但是在这种默认的盒子模型下，`height`、`width`属性的应用范围是内容本身，此时元素盒子的实际高度和实际宽度的计算是比较复杂的，因为需要将内容本身的宽高度再加上填充长度再加上边框宽度才是盒子模型最后的宽度，所以可以将`box-sizing`属性的值修改为`border-box`。在`border-box`下，`height`、`width`属性应用的范围是包含`border`、`padding`、`内容`在内的全部范围。此时，就不需要再手动计算元素盒子的实际宽度和高度了，直接使用`width`、`height`即可。**需要注意的是，在`box-sizing:border-box`下，再指定元素的`padding`、`border`值时，这部分的值将会从实际内容区域中扣减掉（即实际内容区域将会减小）。**



可以使用全局选择器指定所有元素的盒子模型都是`border-box`，同时指定所有元素的默认填充`padding`、边距`margin`的值都是0，方便开发调试。

```css
*{
	margin: 0;
	padding:0 ;
	box-sizing: border-box;
}
```



## 元素类型

HTML元素根据默认布局方式的不同，分为块级元素、内联元素（也叫行内元素）、内联块元素三种。



### 块级元素

常用的标签如：div、p、ul、li、h1~h6、dl、dt、dd等等都是块元素，它在布局中的行为：

1. 支持全部的样式
2. 如果没有设置宽度，默认的宽度为父级宽度100%
3. 默认情况下，块级元素总是单独占据一行、即使设置了宽度



通过`display:block`可以将其他类型的元素转换为块级元素。

### 内联元素

内联元素也叫行内元素，常见的内联元素有`strong`、`em`、`a`、`img`、`button`元素等。它在布局中的行为：

1. 支持部分样式
2. 宽高由实际内容决定
3. 不同的内联元素并在同一行里，不会换行
4. 使用CSS代码强制换行，盒子之间会产生间距
5. 子元素是内联元素时，父元素可以用`text-align`属性设置子元素水平对齐方式。





通过`display:inline`可以把其他类型的元素转换为内联元素。



**需要特别注意的是，对于内联元素，宽度和高度是没有效果的，填充(padding)和外边距(margin)也只会在水平方向上起作用。**

### 内联块元素

**内联块元素，也叫行内块元素，是新增的元素类型，现有元素没有归于此类别的**，`img`和`input`元素的行为类似这种元素，但是也归类于内联元素，可以用display属性将块元素或者内联元素转化成这种元素。它们在布局中表现的行为：

1. 支持全部样式
2. 如果没有设置宽高，宽高由内容决定
3. 只占用需要的空间，会和其他内联块元素和内联元素并在一行
4. 代码换行，盒子会产生间距
5. 子元素是内联块元素，父元素可以用`text-align`属性设置子元素水平对齐方式。



总结一下就是，内联块元素在外部表现得像内联元素（所以它们会并在同一行内显示），但是在内部表现得像是块级元素（所以可以设置宽度和高度）。



可以使用`display:inline-block`来将其他类型的元素转换为内联块元素。实际开发时，可以灵活地将内联元素转换为内联块元素来应用相应的样式。



## CSS定位

CSS中有几种几种不同的定位模式，可以通过`position`属性进行设置，该属性的可选值：

1. static

   元素的默认定位模式，没有定位，元素出现在正常的文档流中

2. relative

   该关键字下，元素默认先被放置在未添加定位时的默认位置，再使用`left`、`top`、`right`、`bottom`属性相对于默认位置调整定位（此时，相对定位元素会相对原默认位置出现偏移，原默认位置会变为空白）。

   

   如果想要让一个父元素的某个子元素（可以不是直接子元素）相对于父元素进行绝对定位，则父元素需要是`relative`相对定位的。

3. fixed

   元素会被移出正常文档流，并不为元素预留空间，而是通过指定元素相对于屏幕视口（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变。打印时，元素会出现在的每页的固定位置。`fixed` 属性会创建新的层叠上下文。当元素祖先的 `transform`、`perspective`、`filter` 或 `backdrop-filter` 属性非 `none` 时，容器由视口改为该祖先。

4. absolute

   可以将任何元素绝对定位于页面上的任何位置，**这种绝对定位模式会使对应的元素脱离原有文档流**，并使其完全失去对周围其他元素的任何影响（甚至会与其他元素重叠）。而且这种定位将是相对于一个相对定位的父容器而言的；**也就是说，如果想要对某个元素设置绝对定位，则这个元素的某一个父级元素（不需要必须是父元素）需要是相对（relative）定位的。**绝对元素定位的位置通过 "left", "top", "right" 以及 "bottom" 属性进行定位，最终定位位置是相对于其第一个`relative`的父级元素（不需要必须是父元素）而言的。**如果绝对定位元素的父元素是`body`且`body`未设置`relative`相对定位的话，则绝对定位元素的位置是相对于视口`viewport`而言的，也就是相对于浏览器当前窗口范围内进行绝对定位。**

   

   未通过left、top、right、bottom属性设置绝对定位元素的位置时，默认情况下，绝对定位元素的位置将出现在其第一个父级元素的左上角（即top和left都是0）。

5. sticky

   元素根据正常文档流进行定位，但是在页面滚动时，该元素不会跟随页面一起滚动（显示/消失），而是始终位于其默认相对于视口`viewport`的位置。相当于是相对定位和固定定位的结合，既有相对定位的保留自己原来位置的特点又有固定定位相对于可视窗口定位的特点。



## 伪元素

伪元素本质上是HTML中不存在的，但是仍然可以在CSS中选择并设置样式的元素。



伪元素在CSS中以两个冒号(::)表示。



常用伪元素

1. first-letter

   ```css
   h1::first-letter{
   	font-style: normal;
       margin-right: 5px;
   }
   ```

   选中`h1`元素的第一个字符

2. first-line

   ```css
   p::first-line{
   	color: red;
   }
   ```

   选择p元素中的第一行内容。

3. +

   ```css
   h3 + p::first-line{
   	color: red;
   }
   ```

   相邻兄弟选择器。选中紧跟`h3`标题后的兄弟`p`元素的第一行。

4. after/before

   ```css
   h2::after{
   	/**
       设置伪元素内容,即使伪元素没有实际内容，仍然需要定义content属性
   	*/
   	content: "TOP";
   	background-color: #ffe70e;
       color: #000;
       font-size: 16px;
       font-weight: bold;
   	display: inline-block;
       padding: 5px 10px;
       position: absolute;
       top: -10px;
       right: -25px;
   }
   ```

   

   **after/before伪元素可用于设置指定元素的最后一个/第一个子元素。**after/before伪元素对于不想创建真实HTML元素但是又想设置样式的装饰元素的场景(比如页面上的一个标识符)非常有帮助。

   

   **需要特别注意的是，`after/before`创建的伪元素默认元素类型是内联元素。**



## 布局

### Float浮动布局

这是使用`float`属性实现布局的老方式，目前已经基本上不会在新项目中使用。

例如：**`float: left; `将页面元素设置为向左浮动后，元素将会像绝对定位一样脱离正常文档流。**浮动元素周围的元素都将会在它周围漂浮(这一点在周围的文本元素特别多时表现得更加明显)。 假如先后有两个块级元素 A、B，如果把 A 设置为 float: left 但是不设置 B 元素为浮动，此时 B 元素将会在 A  元素的右侧紧贴着 A 元素漂浮显示，但是此时 B 元素的左填充、左边距并不是相较于 A 元素的最右侧计算的，其依然是相较于 A  元素的最左侧计算，因为此时只有 A 元素脱离了文档流，B 元素并没有，所以虽然视觉效果上看起来 B 元素是在 A 元素右侧紧贴着 A 元素的，其计算时依然是参照文档流中的位置进行计算。但是如果把 A、B 元素均设置为浮动，此时 B 元素仍然紧贴着 A  元素的右侧，但是其计算左填充、左外边距的时候就变成根据 A 元素的右侧进行计算了，因为此时 A、B 元素都已脱离文档流，再次处于同一区域中。 设置了浮动的元素依然可以设置 margin 值来调整浮动元素与页面上其他仍处在文档流中的元素的外边距。

还有一条有关浮动需要注意的是当一个块级元素没有设置高度 height  值（高度自动扩展）时，如果这个块级元素内部的元素都变成了浮动元素，即其内部的元素都脱离了文档流，则这个父块级元素的高度将会失去高度，这就是"折叠元素"（元素的高度已经被折叠了），因为其内部已经没有实际上可以显示在文档流中的元素了，所以其高度变成了 0。避免这种副作用最好的方式就是使用 clear 来设置不想被浮动元素影响的元素（清除其围绕浮动元素漂浮的效果），可以使用 .container::after{content: '';display:  block;clear:both}来实现，这样就不需要手动在容器最后添加一个 HTML  元素来清除浮动了。元素被清除浮动之后，其将不会再围绕着浮动元素漂浮，而是依然在其原本的位置中。使用这个特性可以灵活的用来实现多个块级元素的并排、并列布局。**如果想让浮动元素相邻的元素不要跟随在浮动元素周围漂浮显示的话，也可以对相应的元素使用`clear`属性清除浮动。**

当在一行中有两个浮动元素，一个向左浮动，一个向右浮动且这两个元素的宽度之和不等于其父元素的宽度之和时，这两个元素中间会自动露出相应的空白区域，这一点可以非常方便的用于页面布局美化。

**浮动和绝对定位的都会使元素脱离文档流，不同之处在于浮动元素会影响其周围的其他元素，使其他元素漂浮在它周围，而绝对定位与其周围的元素之间不会有任何影响。**



### Flexbox

`Flexbox` 是一种用于按行或按列布局元素的一维布局方法。元素可以膨胀以填充额外的空间，收缩以适应更小的空间。

长久以来，CSS 布局中唯一可靠且跨浏览器兼容的创建工具只有 `float` 和  `position`。这两个工具大部分情况下都很好使，但是在某些方面它们具有一定的局限性，让人难以完成任务。以下简单的布局需求是难以或不可能用这样的工具（`float` 和 `position`）方便且灵活的实现的：

1. 在父内容里面垂直居中一个块内容。
2. 使容器的所有子项占用等量的可用宽度/高度，而不管有多少宽度/高度可用。
3. 使多列布局中的所有列采用相同的高度，即使它们包含的内容量不同。

`Flexbox` 使得这些布局任务变得更加容易。

要使用 flexbox，首先要创建弹性容器，可以通过在容器上添加 `display: flex`实现。这样弹性容器的所有直接子元素都将变为弹性元素。这些弹性元素的布局方向称为主轴。另外一个轴称为辅轴。主轴和辅轴可以通过设置属性调换。

对于弹性容器，有以下几个需要记住的属性：

1. gap 可以在不使用 margin 外边距的情况下在各元素之间创建间隔。

2. justify-content 沿主轴对齐项目（默认情况下水平对齐）的方式 可选值有：flex-start | flex-end | center | space-between | space-around | space-evenly 

   **space-between 可以实现均分排满主轴的效果，经常拿来实现分别在最左侧和最右侧展示两个元素的效果。**

3. align-items 沿辅轴对齐项目（默认情况下垂直对齐）的方式 stretch | flex-start | flex-end | center | baseline

4. flex-direction 定义哪个是主轴 row | row-reverse | column | column-reverse

5. flex-wrap 设置在项目太大的时候是否可以换行 nowrap | wrap | wrap-reverse

6. align-content 在元素有多行时适用 stretch | flex-start | flex-end | center | space-between | space-around

对于弹性容器内部的容器元素，也有几个需要记住的属性：

1. align-self 重新设置单个弹性容器元素的对齐属性（而不是适用弹性容器设置的的默认对齐方式） 可选值有: auto | stretch | flex-start | flex-end | center | baseline

2. flex-grow 

   flex-grow的默认值为0。这个属性可以允许弹性元素自动扩大以占据多余的空白空间，如果对一个弹性容器内的所有弹性元素均设置一个相同的 flex-grow 非零 值，则所有弹性元素将均分剩余空白空间，如果只对其中的指定某几项弹性元素设置，则将由这几项分别具有响应的空间，具体分得的空间将由每一项的  flex-grow 值占总值的比例计算得出。

3. flex-shrink 设置当空间不够时弹性元素的伸缩方式，默认值为 1（即允许伸缩），如果将其设置为 0，则将不允许收缩（如果此时设置了 flex-basis  的值，则将以 flex-basis 的值作为统一大小，但是此时因为不允许收缩，所以可能会出现元素显示范围超出容器的情况）。

4. flex-basis

   flex-basis的默认值为auto， 作用与 width  相同，用于设置一个弹性元素的基本宽度，但是并不代表设置了这个值后，所有元素的大小都是这个值，弹性容器允许弹性元素根据其需要的空间自动调整大小（即 flex-shrink 默认为 1），因此，flex-basis 更像是一个基准值。在弹性容器中，应该使用 flex-basis 替代  width 设置元素宽度。

5. flex: 0 1 auto 简写法，共有三个值，分别表示 flex-grow，-shrink、basis

6. order 不需要改变弹性元素在代码中的顺序即可定义真正显示时的先后顺序，弹性元素的默认order为0，默认按照升序排列。



可以使用`flex: flex-grow flex-shrink flex-basis`的速记表示法一次性表示`flex-grow`、`flex-shrink`、`flex-basis`三个属性。



**对于需要明确指定宽度的弹性元素，需要通过`flex-basis`指定最佳宽度，对于其他的没有那么需要明确指定宽度的弹性元素，可以将其`flex-grow`设置为1（根据其他弹性元素的宽度自动调节自身宽度），这样就只需要在个别的弹性元素上指定宽度及指定弹性容器的`gap`间隙值即可实现弹性元素宽度自动计算的效果。省去了手动计算元素宽度并逐个指定的步骤。**



使用 flexbox 的一个很明显的好处在于，对弹性容器素中的多个弹性元素，只需要设置好其中的部分元素，并且设置好其他元素的 flex 值后（比如 flex: 1 代表这个弹性元素将尽可能地占据剩余的空间），浏览器会自动计算出所有元素应该占据地空间。

### Grid

`Grid`可以实现构建完整的二维布局，这使得它非常适合实现页面整体布局。
